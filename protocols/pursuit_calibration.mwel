// ======================== Eye interface include (choose ONE) ========================
// For desktop testing (mouse-as-eye):
// %include '../eye_interfaces/mouse.mwel'

// For deployment with EyeLink (uncomment this and comment the mouse include above):
%include '../eye_interfaces/eyelink.mwel'
// ===================================================================================


// ======================== Reward / output interface (optional) =====================
// Uncomment if using LabJack output interface:
%include '../output_interfaces/firmata.mwel'
// var reward_line = 0
// ===================================================================================

stimulus_display (background_color = 0,0,0)


// ================== Tunable parameters ==================
var trial_count              = 0
var inter_trial_duration     = 800ms

// Pursuit config
var ball_size                = 3.0           // deg
var max_ball_speed           = 20.0          // deg/s
var n_cycles                 = 1.0
var pursuit_delay_dur        = 0ms

// Directions (deg)
var pursuit_thetas           = [0, 90, 180, 270]

// Velocity match / reward pulsing
var min_ball_speed           = 1.0           // deg/s
var min_gaze_speed           = 0.5           // deg/s
var speed_tol                = 10.0           // deg/s tolerance
var hold_pulse_on_ms         = 50
var hold_pulse_off_ms        = 150

// Safety for dt
var dt_s_min                 = 0.005         // seconds (5ms)
// ========================================================


// ----------------- Utility macros -----------------
%define cos_deg(deg) cos(deg * pi() / 180)
%define sin_deg(deg) sin(deg * pi() / 180)

%define sample_theta ()
    p_theta = pursuit_thetas[disc_rand(0, size(pursuit_thetas) - 1)]
%end

%define pursuit_fn(t_s) pursuit_range * ((1 - cos(2*pi() * pursuit_hz * t_s)) / 2)
// ---------------------------------------------------


// ----------------- Display bounds (deg) -----------------
var display_height = display_bounds("top") - display_bounds("bottom")
var display_width  = display_bounds("right") - display_bounds("left")
// --------------------------------------------------------


// ----------------- State variables -----------------
var p_theta            = 0.0

var pursuit_range      = 5.0
var pursuit_hz         = 0.1
var pursuit_duration_s = 2.0
var pursuit_duration   = 2s

var ball_start_x       = 0.0
var ball_start_y       = 0.0
var ball_x             = 0.0
var ball_y             = 0.0

// Ball color: white default, cyan when velocity matched
var ball_color         = [1,1,1]

// Velocity tracking
var el_t               = 0
var last_el_t          = 0

var last_eye_x         = 0.0
var last_eye_y         = 0.0
var last_ball_x        = 0.0
var last_ball_y        = 0.0

var dt_s               = 0.0
var t_s                = 0.0     // ✅ MUST be declared outside render_actions
var ball_speed         = 0.0
var gaze_speed         = 0.0
var vel_match          = 0

var reward_pulses      = 0
// ---------------------------------------------------


// ----------------- Ball stimulus -----------------
ellipse ball (
    color      = ball_color[0], ball_color[1], ball_color[2]
    x_size     = ball_size
    y_size     = ball_size
    x_position = ball_x
    y_position = ball_y
)
// --------------------------------------------------


// ----------------- Render actions: update ball + compute speeds -----------------
render_actions update_ball_position (
    elapsed_time = el_t  // microseconds
) {
    // ✅ Assign, don’t declare
    t_s = el_t / 1s

    // Update ball position (smooth cosine-ease)
    ball_x = ball_start_x + cos_deg(p_theta) * pursuit_fn(t_s)
    ball_y = ball_start_y + sin_deg(p_theta) * pursuit_fn(t_s)

    // Safe dt (seconds)
    dt_s = max(dt_s_min, (el_t - last_el_t) / 1s)

    // Ball speed (deg/s)
    ball_speed = sqrt(
        pow(ball_x - last_ball_x, 2) +
        pow(ball_y - last_ball_y, 2)
    ) / dt_s

    // Gaze speed (deg/s)
    gaze_speed = sqrt(
        pow(eye_x - last_eye_x, 2) +
        pow(eye_y - last_eye_y, 2)
    ) / dt_s

    // Velocity match gate
    vel_match = (ball_speed > min_ball_speed) and (gaze_speed > min_gaze_speed) and (abs(gaze_speed - ball_speed) <= speed_tol)

    // Color: cyan only when velocity matched, else white
    if (vel_match) {
        ball_color = [0,1,1]
    }
    if (not vel_match) {
        ball_color = [1,1,1]
    }

    // Bookkeeping
    last_el_t   = el_t
    last_eye_x  = eye_x
    last_eye_y  = eye_y
    last_ball_x = ball_x
    last_ball_y = ball_y
}
// ------------------------------------------------------------------------------


// ----------------- Trial sampler -----------------
%define sample_pursuit_trial ()
    sample_theta ()

    pursuit_range = max(
        abs(cos_deg(p_theta)) * display_width,
        abs(sin_deg(p_theta)) * display_height
    ) * 0.4
    pursuit_range = max(1.0, pursuit_range)

    pursuit_hz = max_ball_speed / (2*pi() * pursuit_range)
    pursuit_hz = max(0.01, pursuit_hz)

    pursuit_duration_s = n_cycles / pursuit_hz
    pursuit_duration   = pursuit_duration_s * 1s

    if (disc_rand(0,1) == 0) {
        ball_start_x = -pursuit_range * cos_deg(p_theta)
        ball_start_y = -pursuit_range * sin_deg(p_theta)
    }
    if (disc_rand(0,1) == 1) {
        ball_start_x = 0
        ball_start_y = 0
    }

    ball_start_x += disc_rand(-1, 1) * 0.5 * pursuit_range * sin_deg(p_theta)
    ball_start_y += disc_rand(-1, 1) * 0.5 * pursuit_range * cos_deg(p_theta)

    ball_x = ball_start_x
    ball_y = ball_start_y
%end
// --------------------------------------------------


// ============================ PROTOCOL ============================
protocol {
    task {

        state 'Begin trial' {
            start_io_device (eye_tracker)

            ball_color = [1,1,1]
            vel_match  = 0
            reward_pulses = 0

            sample_pursuit_trial ()

            trial_count += 1

            live_queue_stimulus (ball)
            update_display ()

            report('MSG: TRIAL START, trial_count= $trial_count , theta= $p_theta , range= $pursuit_range , hz= $pursuit_hz , duration_s= $pursuit_duration_s')

            start_timer (
                timer    = pursuit_delay_timer
                duration = pursuit_delay_dur
            )

            goto (
                target = 'Start pursuit'
                when   = timer_expired(pursuit_delay_timer)
            )
        }

        state 'Start pursuit' {
            last_el_t   = 0
            last_eye_x  = eye_x
            last_eye_y  = eye_y
            last_ball_x = ball_x
            last_ball_y = ball_y

            queue_stimulus (update_ball_position)
            update_display ()

            start_timer (
                timer    = pursuit_timer
                duration = pursuit_duration
            )

            goto ('Pursuit loop')
        }

        state 'Pursuit loop' {
            // Pulsing reward WHILE vel_match
            if (vel_match) {
                pulse (
                    variable = reward_line
                    duration = hold_pulse_on_ms * 2ms
                )
                reward_pulses += 1
            }

            wait (hold_pulse_off_ms * 2ms)

            goto (
                target = 'End'
                when   = timer_expired(pursuit_timer)
            )
            goto ('Pursuit loop')
        }

        state 'End' {
            dequeue_stimulus (update_ball_position)
            dequeue_stimulus (ball)
            update_display ()

            report('MSG: TRIAL END, trial_count= $trial_count , total_pulses= $reward_pulses')

            wait (inter_trial_duration)

            stop_io_device (eye_tracker)
            goto ('Begin trial')
        }

    }
}
