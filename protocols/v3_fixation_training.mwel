// ======================== Eye interface include (choose ONE) ========================
// For desktop testing (mouse-as-eye):
%include '../eye_interfaces/mouse.mwel'

// For deployment with EyeLink (uncomment this and comment the mouse include above):
// %include '../eye_interfaces/eyelink.mwel'
// ===================================================================================

// %include '../output_interfaces/labjack.mwel'   // reward_line / hardware output (optional)
var reward_line = 0

stimulus_display (background_color = 0,0,0)

resource ('../sounds')

sound/wav_file reward_sound(
    path='../sounds/reward.wav'
)
sound/wav_file error_sound(
    path='../sounds/error.wav'
)


// ================== Tunable parameters / bounds ==================
var log_msg = ''

var trial_count                  = 0           // count trials completed
var inter_trial_duration         = 2s          // ITI
var feedback_duration            = 200ms       // show GREEN/RED briefly
var trial_time_limit             = 10s         // must succeed within this (per trial)

// v1-style starting values
var start_diameter               = 16          // deg
var start_hold_duration          = 1s          // short hold at the beginning

var min_diameter                 = 2
var max_diameter                 = 16

var min_hold_duration            = 1s
var max_hold_duration            = 5s

var diameter_step                = 2
var hold_step                    = 500ms

var successes_to_tighten         = 3
var failures_to_relax            = 2

// --- Hardware reward control ---
var on_fix_reward_ms             = 50          // priming pulse on fixation acquire (0 = off)
var hold_pulse_on_ms             = 2           // ON during hold (square wave)
var hold_pulse_off_ms            = 2           // OFF during hold (square wave)
var success_reward_ms            = 0           // set to 1 → 8 ms total; 0 disables

// --- Random placement control ---
var edge_padding_deg             = 1.0         // extra pad from edges (deg)
// ================================================================

// ----------------- Adaptive state (v1-style) -----------------
var fixation_diameter            = start_diameter
var fixation_hold_duration       = start_hold_duration
var consecutive_successes        = 0
var consecutive_failures         = 0

// Session-level performance counts
var total_successes              = 0
var total_failures               = 0
// ---------------------------------------------------

// Derived / dynamic
var fixation_radius = 0.5 * fixation_diameter
var fix_color = [1,1,1]   // RGB

// Randomized position each trial
var fix_x = 0
var fix_y = 0

// Circle at (fix_x, fix_y) (live-updated)
ellipse fixation_circle (
    color      = fix_color[0], fix_color[1], fix_color[2]
    x_size     = fixation_diameter
    y_size     = fixation_diameter
    x_position = fix_x
    y_position = fix_y
)

// Helpers
%define show_circle ()
    live_queue_stimulus (fixation_circle)
%end

%define hide_circle ()
    dequeue_stimulus (fixation_circle)
%end

// Eye coordinates come from the selected eye interface include (mouse or EyeLink)
%define gaze_in_fixation () (
    pow(eye_x - fix_x, 2) + pow(eye_y - fix_y, 2) <= pow(fixation_radius, 2)
)

// Randomize fixation position within padded bounds (respect circle radius)
%define sample_fix_position ()
    fix_x = rand(
        display_bounds('left')  + fixation_radius + edge_padding_deg,
        display_bounds('right') - fixation_radius - edge_padding_deg
    )
    fix_y = rand(
        display_bounds('bottom') + fixation_radius + edge_padding_deg,
        display_bounds('top')    - fixation_radius - edge_padding_deg
    )
%end

// v1-style staircase helpers: shorter→longer, bigger→smaller with successes
%define tighten_difficulty ()
    fixation_diameter = max(min_diameter, fixation_diameter - diameter_step)
    fixation_radius   = 0.5 * fixation_diameter
    fixation_hold_duration = min(max_hold_duration, fixation_hold_duration + hold_step)
%end

%define relax_difficulty ()
    fixation_diameter = min(max_diameter, fixation_diameter + diameter_step)
    fixation_radius   = 0.5 * fixation_diameter
    fixation_hold_duration = max(min_hold_duration, fixation_hold_duration - hold_step)
%end
// -------------------------------------------------------

protocol {
    task {
        state 'Begin trial' {
            start_io_device (eye_tracker)

            // Recompute radius from current staircase state (diameter may have changed)
            fixation_radius = 0.5 * fixation_diameter

            // Sample a new random position with edge padding
            sample_fix_position ()

            // Start in WHITE at the sampled position/size
            fix_color = [1,1,1]
            show_circle ()
            update_display ()

            trial_count += 1

            report('MSG: TRIAL START, trial_count= $trial_count , diameter= $fixation_diameter , fixation_time= $fixation_hold_duration s, pos= ($fix_x , $fix_y) , successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')

            // per-trial timeout
            start_timer (
                timer = trial_timer
                duration = trial_time_limit
            )

            goto ('Wait for fixation entry')
        }

        state 'Wait for fixation entry' {
            goto (
                target = 'Timeout failure'
                when = timer_expired(trial_timer)
            )
            goto (
                target = 'Fixation acquired'
                when = gaze_in_fixation()
            )
        }

        // On acquire: cyan, optional priming pulse, then start hold timer
        state 'Fixation acquired' {
            fix_color = [0,1,1]
            update_display ()

            if (on_fix_reward_ms > 0) {
                pulse (
                    variable = reward_line
                    duration = on_fix_reward_ms * 5ms
                )
                report('MSG: ON_FIX_PULSE, ms= $on_fix_reward_ms , trial_count= $trial_count , diameter= $fixation_diameter , fixation_time= $fixation_hold_duration s, pos= ($fix_x , $fix_y) , successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')
            }

            start_timer (
                timer = hold_timer
                duration = fixation_hold_duration
            )
            goto ('Fixation pulsing')
        }

        // Continuous square-wave reward while fixating
        state 'Fixation pulsing' {
            // --- actions first (MWEL rule) ---
            pulse (
                variable = reward_line
                duration = hold_pulse_on_ms * 1ms
            )
            wait  (hold_pulse_off_ms * 1ms)

            // --- transitions after actions ---
            goto (
                target = 'Fixation success'
                when = timer_expired(hold_timer)
            )
            goto (
                target = 'Timeout failure'
                when = timer_expired(trial_timer)
            )
            goto (
                target = 'Fixation broken'
                when = not gaze_in_fixation()
            )

            // loop if still fixating and no timeout/success
            goto ('Fixation pulsing')
        }

        state 'Fixation broken' {
            fix_color = [1,1,1]   // back to WHITE
            update_display ()
            goto ('Wait for fixation entry')
        }

        // ---------- SUCCESS PATH ----------
        state 'Fixation success' {
            // Update session-level success count first
            total_successes += 1

            fix_color = [0,1,0]   // GREEN
            update_display ()
            play_sound (reward_sound)

            // Optional extra success pulse at end of fixation
            if (success_reward_ms > 0) {
                pulse (
                    variable = reward_line
                    duration = success_reward_ms * 8ms
                )
                report('MSG: SUCCESS_PULSE, ms= $success_reward_ms , trial_count= $trial_count , diameter= $fixation_diameter , fixation_time= $fixation_hold_duration s, pos= ($fix_x , $fix_y) , successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')
            }

            // Explicit log that reward was delivered after success
            report('MSG: REWARD_AFTER_SUCCESS, trial_count= $trial_count , diameter= $fixation_diameter , fixation_time= $fixation_hold_duration s, pos= ($fix_x , $fix_y) , successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')

            wait (feedback_duration)

            hide_circle ()
            update_display ()

            report('MSG: TRIAL SUCCESS, trial_count= $trial_count , diameter= $fixation_diameter , fixation_time= $fixation_hold_duration s, pos= ($fix_x , $fix_y) , successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')

            goto ('Update after success')
        }

        state 'Update after success' {
            consecutive_successes += 1
            consecutive_failures   = 0

            if (consecutive_successes >= successes_to_tighten) {
                tighten_difficulty ()
                consecutive_successes = 0
                report('MSG: STAIRCASE_UP, trial_count= $trial_count , new_diameter= $fixation_diameter , new_fixation_time= $fixation_hold_duration s, successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')
            }

            goto ('ITI')
        }

        // ---------- FAILURE PATH (timeout) ----------
        state 'Timeout failure' {
            // Update session-level failure count first
            total_failures += 1

            fix_color = [1,0,0]   // RED
            update_display ()
            play_sound (error_sound)
            wait (feedback_duration)

            hide_circle ()
            update_display ()

            report('MSG: TRIAL FAILURE, trial_count= $trial_count , diameter= $fixation_diameter , fixation_time= $fixation_hold_duration s, pos= ($fix_x , $fix_y) , successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')

            goto ('Update after failure')
        }

        state 'Update after failure' {
            consecutive_failures   += 1
            consecutive_successes   = 0

            if (consecutive_failures >= failures_to_relax) {
                relax_difficulty ()
                consecutive_failures = 0
                report('MSG: STAIRCASE_DOWN, trial_count= $trial_count , new_diameter= $fixation_diameter , new_fixation_time= $fixation_hold_duration s, successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')
            }

            goto ('ITI')
        }

        // ---------- ITI & Loop ----------
        state 'ITI' {
            wait (inter_trial_duration)
            goto ('End trial')
        }

        state 'End trial' {
            stop_io_device (eye_tracker)
            goto ('Begin trial')   // continuous training loop
        }
    }
}
