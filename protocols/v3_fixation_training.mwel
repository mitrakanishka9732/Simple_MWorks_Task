// ======================== Eye interface include (choose ONE) ========================
// For desktop testing (mouse-as-eye):
%include '../eye_interfaces/mouse.mwel'

// For deployment with EyeLink (uncomment this and comment the mouse include above):
//%include '../eye_interfaces/eyelink.mwel'
// ===================================================================================

// %include '../output_interfaces/labjack.mwel'   // reward_line / hardware output (optional)
// %include '../output_interfaces/firmata.mwel'
var reward_line = 0

stimulus_display (background_color = 0,0,0)

resource ('../sounds')

sound/wav_file reward_sound(
    path='../sounds/reward.wav'
)
sound/wav_file error_sound(
    path='../sounds/error.wav'
)


// ================== Tunable parameters / bounds ==================
var log_msg = ''

var trial_count                  = 0           // count trials completed
var inter_trial_duration         = 200ms       // baseline ITI
var feedback_duration            = 200ms       // show GREEN/RED briefly
var trial_time_limit             = 5s          // must succeed within this (per trial)

// v1-style starting values
var start_diameter               = 14          // deg
var start_hold_duration          = 200ms       // short hold at the beginning

var min_diameter                 = 1
var max_diameter                 = 14

var min_hold_duration            = 200ms
var max_hold_duration            = 5s

var diameter_step                = 1.75
var hold_step                    = 250ms

var successes_to_tighten         = 3
var failures_to_relax            = 2

// --- Hardware reward control ---
// NOTE: As requested, **no reward** on acquisition or during hold.
// Only reward after success via success_reward_ms.
var success_reward_ms            = 300         // ms of juice after success (set 0 to disable)

// --- Random placement control ---
var edge_padding_deg             = 1.0         // extra pad from edges (deg)

// --- ITI escalation control after error streaks ---
var iti_baseline                 = 200ms       // reference baseline ITI
var error_block_count            = 0           // how many 3-error blocks have occurred
var consecutive_error_trials     = 0           // counts consecutive error trials
var extended_iti_pending         = 0           // flag: apply extended ITI on next ITI state
var extended_iti_duration        = 200ms       // duration to use when extended ITI is pending
// ================================================================

// ----------------- NEW: trial timing & per-trial metrics -----------------
var session_start_us             = 0
var session_start_str            = ''

var trial_start_us               = 0
var trial_start_str              = ''

var trial_outcome_us             = 0   // moment of success/failure (excludes ITI)
var trial_outcome_str            = ''
var trial_outcome_dur_ms         = 0

var trial_end_us                 = 0   // end of ITI, just before next trial begins
var trial_end_str                = ''
var trial_total_dur_ms           = 0

// 1 = success, 0 = failure (timeout)
var trial_result                 = 0

// fixation behavior metrics
var fix_first_acq_us             = 0
var fix_first_acq_latency_ms     = -1
var fix_acq_count                = 0
var fix_break_count              = 0

var hold_start_us                = 0
var hold_elapsed_ms              = 0
// ---------------------------------------------------------------


// ----------------- Adaptive state (v1-style) -----------------
var fixation_diameter            = start_diameter
var fixation_hold_duration       = start_hold_duration
var consecutive_successes        = 0
var consecutive_failures         = 0

// Session-level performance counts
var total_successes              = 0
var total_failures               = 0

// For logging fixation time in ms
var fixation_hold_ms             = 0
// ---------------------------------------------------

// Derived / dynamic
var fixation_radius = 0.5 * fixation_diameter
var fix_color = [1,1,1]   // RGB

// Randomized position each trial
var fix_x = 0
var fix_y = 0

// Circle at (fix_x, fix_y) (live-updated)
ellipse fixation_circle (
    color      = fix_color[0], fix_color[1], fix_color[2]
    x_size     = fixation_diameter
    y_size     = fixation_diameter
    x_position = fix_x
    y_position = fix_y
)

// Helpers
%define show_circle ()
    live_queue_stimulus (fixation_circle)
%end

%define hide_circle ()
    dequeue_stimulus (fixation_circle)
%end

// Eye coordinates come from the selected eye interface include (mouse or EyeLink)
%define gaze_in_fixation () (
    pow(eye_x - fix_x, 2) + pow(eye_y - fix_y, 2) <= pow(fixation_radius, 2)
)

// Randomize fixation position within padded bounds (respect circle radius)
%define sample_fix_position ()
    fix_x = rand(
        display_bounds('left')  + fixation_radius + edge_padding_deg,
        display_bounds('right') - fixation_radius - edge_padding_deg
    )
    fix_y = rand(
        display_bounds('bottom') + fixation_radius + edge_padding_deg,
        display_bounds('top')    - fixation_radius - edge_padding_deg
    )
%end

// v1-style staircase helpers
%define tighten_difficulty ()
    fixation_diameter      = max(min_diameter, fixation_diameter - diameter_step)
    fixation_radius        = 0.5 * fixation_diameter
    fixation_hold_duration = min(max_hold_duration, fixation_hold_duration + hold_step)
%end

%define relax_difficulty ()
    fixation_diameter      = min(max_diameter, fixation_diameter + diameter_step)
    fixation_radius        = 0.5 * fixation_diameter
    fixation_hold_duration = max(min_hold_duration, fixation_hold_duration - hold_step)
%end
// -------------------------------------------------------

protocol {
    task {
        state 'Begin trial' {
            start_io_device (eye_tracker)

            // Session start (once)
            if (session_start_us == 0) {
                session_start_us  = now()
                session_start_str = date("%Y-%m-%d %H:%M:%S")
                report('MSG: SESSION START, session_start_us= $session_start_us , session_start_str= $session_start_str')
            }

            // Trial start timing + reset per-trial metrics
            trial_start_us   = now()
            trial_start_str  = date("%Y-%m-%d %H:%M:%S")
            trial_outcome_us = 0
            trial_result     = 0

            fix_first_acq_us         = 0
            fix_first_acq_latency_ms = -1
            fix_acq_count            = 0
            fix_break_count          = 0
            hold_start_us            = 0
            hold_elapsed_ms          = 0

            // Recompute radius from current staircase state (diameter may have changed)
            fixation_radius = 1.25 * fixation_diameter

            // Sample a new random position with edge padding
            sample_fix_position ()

            // Start in WHITE at the sampled position/size
            fix_color = [1,1,1]
            show_circle ()
            update_display ()

            trial_count += 1

            // For reporting: convert hold duration to ms
            fixation_hold_ms = fixation_hold_duration / 1ms

            report('MSG: TRIAL START, trial_count= $trial_count , start_us= $trial_start_us , start_str= $trial_start_str , diameter= $fixation_diameter , fixation_time= $fixation_hold_ms ms, pos= ($fix_x , $fix_y) , successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')

            // per-trial timeout
            start_timer (
                timer = trial_timer
                duration = trial_time_limit
            )

            goto ('Wait for fixation entry')
        }

        state 'Wait for fixation entry' {
            goto (
                target = 'Timeout failure'
                when = timer_expired(trial_timer)
            )
            goto (
                target = 'Fixation acquired'
                when = gaze_in_fixation()
            )
        }

        // On acquire: CYAN, but **no reward** here.
        state 'Fixation acquired' {
            // Count acquisitions
            fix_acq_count += 1

            // First acquisition latency (ms from trial start)
            if (fix_first_acq_us == 0) {
                fix_first_acq_us         = now()
                fix_first_acq_latency_ms = (fix_first_acq_us - trial_start_us) / 1ms
            }

            // Hold timing bookkeeping
            hold_start_us = now()

            fix_color = [0,1,1]
            update_display ()

            // Start the required hold timer
            start_timer (
                timer = hold_timer
                duration = fixation_hold_duration
            )

            goto ('Hold fixation')
        }

        // Hold fixation with NO juice; just timing & monitoring
        state 'Hold fixation' {
            goto (
                target = 'Fixation success'
                when = timer_expired(hold_timer)
            )
            goto (
                target = 'Timeout failure'
                when = timer_expired(trial_timer)
            )
            goto (
                target = 'Fixation broken'
                when = not gaze_in_fixation()
            )
        }

        state 'Fixation broken' {
            fix_break_count += 1
            fix_color = [1,1,1]   // back to WHITE
            update_display ()
            goto ('Wait for fixation entry')
        }

        // ---------- SUCCESS PATH ----------
        state 'Fixation success' {
            // Update session-level success count first
            total_successes += 1
            trial_result = 1

            // A success breaks any error streak
            consecutive_error_trials = 0

            // Outcome timing (exclude ITI)
            trial_outcome_us     = now()
            trial_outcome_str    = date("%Y-%m-%d %H:%M:%S")
            trial_outcome_dur_ms = (trial_outcome_us - trial_start_us) / 1ms

            // How long the last hold segment actually lasted (ms)
            hold_elapsed_ms = (trial_outcome_us - hold_start_us) / 1ms

            // GREEN + reward sound
            fix_color = [0,1,0]
            update_display ()
            play_sound (reward_sound)

            // *** ONLY HERE: deliver juice reward ***
            if (success_reward_ms > 0) {
                pulse (
                    variable = reward_line
                    duration = success_reward_ms * 1ms
                )
                fixation_hold_ms = fixation_hold_duration / 1ms
                report('MSG: SUCCESS_PULSE, ms= $success_reward_ms , trial_count= $trial_count , diameter= $fixation_diameter , fixation_time= $fixation_hold_ms ms, pos= ($fix_x , $fix_y)')
            }

            fixation_hold_ms = fixation_hold_duration / 1ms
            report('MSG: OUTCOME_SUCCESS, trial_count= $trial_count , outcome_us= $trial_outcome_us , outcome_str= $trial_outcome_str , outcome_dur_ms= $trial_outcome_dur_ms , first_acq_latency_ms= $fix_first_acq_latency_ms , acq_count= $fix_acq_count , break_count= $fix_break_count , last_hold_elapsed_ms= $hold_elapsed_ms , successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')

            wait (feedback_duration)

            hide_circle ()
            update_display ()

            goto ('Update after success')
        }

        state 'Update after success' {
            consecutive_successes += 1
            consecutive_failures   = 0

            if (consecutive_successes >= successes_to_tighten) {
                tighten_difficulty ()
                consecutive_successes = 0
                fixation_hold_ms = fixation_hold_duration / 1ms
                report('MSG: STAIRCASE_UP, trial_count= $trial_count , new_diameter= $fixation_diameter , new_fixation_time= $fixation_hold_ms ms')
            }

            goto ('ITI')
        }

        // ---------- FAILURE PATH (timeout) ----------
        state 'Timeout failure' {
            // Update session-level failure count first
            total_failures += 1
            trial_result = 0

            // Update streak of error trials
            consecutive_error_trials += 1

            // Outcome timing (exclude ITI)
            trial_outcome_us     = now()
            trial_outcome_str    = date("%Y-%m-%d %H:%M:%S")
            trial_outcome_dur_ms = (trial_outcome_us - trial_start_us) / 1ms

            fix_color = [1,0,0]   // RED
            update_display ()
            play_sound (error_sound)
            wait (feedback_duration)

            hide_circle ()
            update_display ()

            fixation_hold_ms = fixation_hold_duration / 1ms
            report('MSG: OUTCOME_TIMEOUT, trial_count= $trial_count , outcome_us= $trial_outcome_us , outcome_str= $trial_outcome_str , outcome_dur_ms= $trial_outcome_dur_ms , first_acq_latency_ms= $fix_first_acq_latency_ms , acq_count= $fix_acq_count , break_count= $fix_break_count , diameter= $fixation_diameter , fixation_time= $fixation_hold_ms ms, pos= ($fix_x , $fix_y) , successes= $total_successes / $trial_count , failures= $total_failures / $trial_count')

            goto ('Update after failure')
        }

        state 'Update after failure' {
            // Staircase logic for difficulty
            consecutive_failures   += 1
            consecutive_successes   = 0

            if (consecutive_failures >= failures_to_relax) {
                relax_difficulty ()
                consecutive_failures = 0
                fixation_hold_ms = fixation_hold_duration / 1ms
                report('MSG: STAIRCASE_DOWN, trial_count= $trial_count , new_diameter= $fixation_diameter , new_fixation_time= $fixation_hold_ms ms')
            }

            // --- ITI escalation based on 3-error streaks ---
            if (consecutive_error_trials >= 3) {
                error_block_count += 1

                // Extended ITI: 2.0s, then 2.1s, 2.2s, ... for each successive 3-error block
                extended_iti_duration = 2s + (error_block_count - 1) * 100ms
                extended_iti_pending  = 1
                consecutive_error_trials = 0

                report('MSG: EXTENDED_ITI_SCHEDULED, trial_count= $trial_count , block_index= $error_block_count , extended_iti= $extended_iti_duration')
            }

            goto ('ITI')
        }

        // ---------- ITI & Loop ----------
        state 'ITI' {
            if (extended_iti_pending) {
                wait (extended_iti_duration)
                extended_iti_pending = 0
            }
            else {
                wait (inter_trial_duration)
            }

            goto ('End trial')
        }

        state 'End trial' {
            // Trial end timing (includes ITI)
            trial_end_us       = now()
            trial_end_str      = date("%Y-%m-%d %H:%M:%S")
            trial_total_dur_ms = (trial_end_us - trial_start_us) / 1ms

            report('MSG: TRIAL END, trial_count= $trial_count , result= $trial_result , end_us= $trial_end_us , end_str= $trial_end_str , total_dur_ms= $trial_total_dur_ms')

            stop_io_device (eye_tracker)
            goto ('Begin trial')   // continuous training loop
        }
    }
}
